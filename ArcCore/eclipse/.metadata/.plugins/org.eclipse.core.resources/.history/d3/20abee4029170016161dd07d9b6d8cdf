package com.thearclightcrusader.ArcCore.dimensions;

import java.util.Arrays;
import java.util.List;
import java.util.Random;

import com.thearclightcrusader.ArcCore.worldgen.BiomeFairyPlains;
import com.thearclightcrusader.ArcCore.worldgen.BiomeFireLands;
import com.thearclightcrusader.ArcCore.worldgen.BiomesAC;

import net.minecraft.crash.CrashReport;
import net.minecraft.crash.CrashReportCategory;
import net.minecraft.util.ReportedException;
import net.minecraft.world.ChunkPosition;
import net.minecraft.world.biome.BiomeGenBase;
import net.minecraft.world.biome.WorldChunkManager;
import net.minecraft.world.biome.WorldChunkManagerHell;
import net.minecraft.world.gen.layer.GenLayer;
import net.minecraft.world.gen.layer.IntCache;
import scala.collection.concurrent.Debug;

public class WorldChunkManagerFairy extends WorldChunkManager {
	
	private BiomeGenBase biomeGenerator;
	private BiomeGenBase biomeFairy;
	private BiomeGenBase biomeIce;
	private int radius = 250;
	private List biomeList;
	private BiomeGenBase[] mainBiomes;
	private BiomeGenBase[] mountainBiomes;
	private boolean flagerino = false;
	private GenLayer biomeIndexLayer;
	
	  public WorldChunkManagerFairy(BiomeGenBase biome, BiomeGenBase[] biomes1, BiomeGenBase[] biomes2, float f) {
		  super();
		  this.biomeIce = BiomesAC.biomeIceMountains;
		  this.biomeFairy = BiomesAC.biomeGildedPlains;
		  this.mainBiomes = biomes1;
		  this.mountainBiomes = biomes2;
	}
	  
	  public BiomeGenBase getBiomeGenAt(int x, int z)
	    {
		  if((x * x) + (z * z) >= radius * radius){
			  this.flagerino = true;
			  System.out.print("Working");
			  return BiomesAC.biomeIceMountains;
			  
			  
		  }else{
			  
			  return BiomesAC.biomeGildedForest;
		  }
	    }
	  
	  public BiomeGenBase[] getBiomesForGeneration(BiomeGenBase[] biomes, int x, int z, int j, int k)
	    {
		  
		  if (biomes == null || biomes.length < j * k)
	        {
	            biomes = new BiomeGenBase[j * k];
	        }
		  
		  if((x * x) + (z * z) >= radius * radius){
			  System.out.print("Working");
			  Arrays.fill(biomes, 0, j * k, BiomesAC.biomeIceMountains);
			  return biomes;
			  
			  
		  }else{
			  Arrays.fill(biomes, 0, j * k, BiomesAC.biomeGildedPlains);
			  return biomes;
		  }
	    }
	  
	    public float[] getRainfall(float[] p_76936_1_, int p_76936_2_, int p_76936_3_, int p_76936_4_, int p_76936_5_)
	    {
	        IntCache.resetIntCache();

	        if (p_76936_1_ == null || p_76936_1_.length < p_76936_4_ * p_76936_5_)
	        {
	            p_76936_1_ = new float[p_76936_4_ * p_76936_5_];
	        }

	        int[] aint = this.biomeIndexLayer.getInts(p_76936_2_, p_76936_3_, p_76936_4_, p_76936_5_);

	        for (int i1 = 0; i1 < p_76936_4_ * p_76936_5_; ++i1)
	        {
	            try
	            {
	                float f = (float)BiomeGenBase.getBiome(aint[i1]).getIntRainfall() / 65536.0F;

	                if (f > 1.0F)
	                {
	                    f = 1.0F;
	                }

	                p_76936_1_[i1] = f;
	            }
	            catch (Throwable throwable)
	            {
	                CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Invalid Biome id");
	                CrashReportCategory crashreportcategory = crashreport.makeCategory("DownfallBlock");
	                crashreportcategory.addCrashSection("biome id", Integer.valueOf(i1));
	                crashreportcategory.addCrashSection("downfalls[] size", Integer.valueOf(p_76936_1_.length));
	                crashreportcategory.addCrashSection("x", Integer.valueOf(p_76936_2_));
	                crashreportcategory.addCrashSection("z", Integer.valueOf(p_76936_3_));
	                crashreportcategory.addCrashSection("w", Integer.valueOf(p_76936_4_));
	                crashreportcategory.addCrashSection("h", Integer.valueOf(p_76936_5_));
	                throw new ReportedException(crashreport);
	            }
	        }

	        return p_76936_1_;
	    }

	    public ChunkPosition findBiomePosition(int x, int y, int z, List list, Random random)
	    {
	    		if((x * x) + (z * z) < (radius * radius)){
	    			return new ChunkPosition(x, y, z);
	    			
	    		}else if((x * x) + (z * z) >= (radius * radius)){
	    				
	    				return new ChunkPosition(x++, y, z++);
	    			}
	    		
	    		return null;
	    }
	    
	    	
	    

	    /**
	     * checks given Chunk's Biomes against List of allowed ones
	     */
	    public boolean areBiomesViable(int p_76940_1_, int p_76940_2_, int p_76940_3_, List p_76940_4_)
	    {
	        return p_76940_4_.contains(BiomesAC.biomeIceMountains); //|| p_76940_4_.contains(BiomesAC.biomeGildedPlains);
	    }
}
